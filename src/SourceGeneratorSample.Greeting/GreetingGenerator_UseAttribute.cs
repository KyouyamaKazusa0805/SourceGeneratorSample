namespace SourceGeneratorSample.UseAttributes;

/// <summary>
/// 使用特性来标记方法，然后编译产生源代码，打招呼。
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class GreetingGenerator_UseAttribute : ISourceGenerator
{
	/// <inheritdoc/>
	public void Execute(GeneratorExecutionContext context)
	{
		if (context is not
			{
				SyntaxContextReceiver: SyntaxContextReceiver
				{
					FoundSymbols: var methodSymbols and not []
				}
			})
		{
			return;
		}

		foreach (var methodSymbol in methodSymbols)
		{
			if (methodSymbol is not
				{
					ContainingType:
					{
						ContainingNamespace: var @namespace,
						Name: var typeName,
						TypeKind: var typeKind
					} containingType,
					Name: var methodName,
					DeclaringSyntaxReferences: [var syntaxReference, ..]
				})
			{
				continue;
			}

			var syntaxNode = (MethodDeclarationSyntax)syntaxReference.GetSyntax();
			var namespaceString = @namespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			namespaceString = namespaceString["global::".Length..];
			var typeKindString = typeKind switch
			{
				TypeKind.Class => "class",
				TypeKind.Struct => "struct",
				TypeKind.Interface => "interface",
				_ => throw new InvalidOperationException("Invalid type kind.")
			};

			context.AddSource(
				$"{typeName}.g.cs",
				$$"""
				// <auto-generated/>

				#nullable enable
				namespace {{namespaceString}};

				partial {{typeKindString}} {{typeName}}
				{
					{{syntaxNode.Modifiers}} void {{methodName}}(string name)
						=> global::System.Console.WriteLine($"Hello, {name}!");
				}
				"""
			);
		}
	}

	/// <inheritdoc/>
	public void Initialize(GeneratorInitializationContext context)
		=> context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
}

/// <summary>
/// 带有一定语义分析功能的语法收集类型。获取到所有标记了 SayHelloAttribute 特性的方法。
/// </summary>
file sealed class SyntaxContextReceiver : ISyntaxContextReceiver
{
	/// <summary>
	/// 表示找到了的方法的定义信息，以及它对应所在类型的信息。
	/// </summary>
	public List<IMethodSymbol> FoundSymbols { get; } = new();


	/// <inheritdoc/>
	public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
	{
		// 判别当前语法节点是否是方法定义。
		// 如果是的话，还需要对象必须标记 partial 关键字。
		// 如果有的话，进行下一步。同时，我们要获取编译信息（Compilation）和
		// 语义模型对象（SemanticModel）。
		if (context is not
			{
				Node: MethodDeclarationSyntax
				{
					Modifiers: var modifiers and not []
				} methodSyntax,
				SemanticModel: { Compilation: var compilation } semanticModel
			})
		{
			return;
		}

		if (!modifiers.Any(SyntaxKind.PartialKeyword))
		{
			return;
		}

		// 获取方法标记了的全部特性信息。
		// 并且通过这些特性，和 attribute 变量进行比较。
		// 比较使用的是 SymbolEqualityComparer.Default 实例进行比较。
		// 如果比较成功，返回 true，说明我们找到的对应的特性，和 SayHelloAttribute 匹配上了，
		// 换言之，这个方法就标记了 SayHelloAttribute。
		var attribute = compilation.GetTypeByMetadataName("SourceGeneratorSample.Greetings.SayHelloAttribute")!;
		var methodSymbol = semanticModel.GetDeclaredSymbol(methodSyntax)!;
		if (!methodSymbol.GetAttributes().Any(predicate))
		{
			return;
		}

		// 方法还必须返回 void、带有一个 string 类型的参数。
		if (methodSymbol is not
			{
				ReturnsVoid: true,
				Parameters: [{ Type.SpecialType: SpecialType.System_String }]
			})
		{
			return;
		}

		FoundSymbols.Add(methodSymbol);


		bool predicate(AttributeData a)
			=> SymbolEqualityComparer.Default.Equals(a.AttributeClass, attribute);
	}
}
